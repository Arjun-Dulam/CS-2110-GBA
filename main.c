#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
#include "movementMethods.h"

#include "images/sisyphus.h"
#include "images/steve.h"
#include "images/boulder.h"
#include "images/youDied.h"
#include "images/mountain.h"
#include "images/fallout.h"


/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

// command to process image: nin10kit --mode=3 --resize=240x160 sisyphus sisyphus.png 

/* TODO: */
// Add any additional states you need for your app. You are not required to use
// these specific provided states.
enum gba_state {
  START_INITIAL,
  START_REGULAR,
  PLAY_INITIAL,
  PLAY_REGULAR,
  TEMP_SUCCESS_INITIAL,
  TEMP_SUCCESS_REGULAR,
  DEATH_INITIAL,
  DEATH_REGULAR
};

static entity Steve = {
  .row = 50,
  .col = 40,
  .image = steve
};

static entity Boulder = {
  .row = 100,
  .col = 200,
  .image = boulder
};

static entity Mountain = {
  .row = 100,
  .col = 30,
  .image = mountain
};

int deathsINT = 0;


int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //

  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state

  enum gba_state state = START_INITIAL;

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    waitForVBlank();

    switch (state) {
      case START_INITIAL:
        fillScreenDMA(BLACK);
        drawImageDMA(40, 60, SISYPHUS_WIDTH, SISYPHUS_HEIGHT, sisyphus);

        state = START_REGULAR;
        break;
        
      case START_REGULAR:
        drawString(135 , 60, "Press Enter to Start", WHITE);
        
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          state = PLAY_INITIAL;
        }
        
        break;
        
      case PLAY_INITIAL:
        fillScreenDMA(BROWN);
        drawRectDMA(0, 0, WIDTH, 20, GREY);
        drawImageDMA(Steve.row, Steve.col, STEVE_HEIGHT, STEVE_WIDTH, steve); 
        drawImageDMA(Boulder.row, Boulder.col, BOULDER_HEIGHT, BOULDER_WIDTH, boulder);
        drawImageDMA(100, 30, MOUNTAIN_WIDTH, MOUNTAIN_HEIGHT, mountain);
        
        
        state = PLAY_REGULAR;
        break;
        
      case PLAY_REGULAR:
        moveEntity(&Steve, currentButtons, BROWN);

        if (detectCollision(&Steve, &Boulder)) {
          // if (KEY_DOWN(BUTTON_UP, currentButtons) && Boulder.row > 20) {
          //   Boulder.row--;
          // } else if (KEY_DOWN(BUTTON_DOWN, currentButtons) && Boulder.row + 10 < HEIGHT) {
          //   Boulder.row++;
          // } else if (KEY_DOWN(BUTTON_LEFT, currentButtons) && Boulder.col < 0) {
          //   Boulder.col--;
          // } else if (KEY_DOWN(BUTTON_RIGHT, currentButtons) && Boulder.col + 10 < WIDTH) {
          //   Boulder.col++;
          // }
          moveEntity(&Boulder, currentButtons, BROWN);
        }

        drawImageDMA(Boulder.row, Boulder.col, 10, 10, boulder);

        if (Steve.row < 20) {
          state = DEATH_INITIAL;
        } else if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons))  {
          state = START_INITIAL;
        } else if (isFullyContained(&Mountain, &Boulder)) {
          state = TEMP_SUCCESS_INITIAL;
        }

        break;

      case TEMP_SUCCESS_INITIAL:
        Steve.row = 50;
        Steve.col = 40;
        Boulder.row = 100;
        Boulder.col = 200;

        drawImageDMA(0, 0, FALLOUT_WIDTH, FALLOUT_HEIGHT, fallout);
        drawCenteredString(0, 0, WIDTH, 20, "You must do this forever. Have fun!", WHITE);

        state = TEMP_SUCCESS_REGULAR;

        break;
      
      case TEMP_SUCCESS_REGULAR:
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START_INITIAL;
        }
        break;
      case DEATH_INITIAL:
        deathsINT++;
        drawImageDMA(0, 0, YOUDIED_WIDTH, YOUDIED_HEIGHT - 40, youDied);
        drawRectDMA(120, 0, WIDTH, 40, BLACK);
        drawCenteredString(20, 0, WIDTH, 10, "Death is not an escape.", WHITE);
        drawCenteredString(40, 0, WIDTH, 10, "You must continue your punishment.", WHITE);
        drawCenteredString(120, 0, WIDTH, 10, "Press delete to start again.", WHITE);
        
        char deathSTR[16]; // Increased size to safely hold the formatted string
        snprintf(deathSTR, sizeof(deathSTR), "Deaths = %d", deathsINT);

        drawCenteredString(140, 0, WIDTH, 10, deathSTR, WHITE);
        state = DEATH_REGULAR;
        break;

      case DEATH_REGULAR:
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          // resetting position

          Steve.row = 50;
          Steve.col = 40;
          Boulder.row = 100;
          Boulder.col = 200;
          state = START_INITIAL;
        }
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}