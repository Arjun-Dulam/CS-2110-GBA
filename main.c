#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
#include "movementMethods.h"

#include "images/sisyphus.h"
#include "images/steve.h"
#include "images/boulder.h"
#include "images/youDied.h"
#include "images/mountain.h"
#include "images/fallout.h"
#include "images/cowboy.h"

/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

// command to process image: nin10kit --mode=3 --resize=240x160 sisyphus sisyphus.png 

/* TODO: */
// Add any additional states you need for your app. You are not required to use
// these specific provided states.
enum gba_state {
  ASK_PREFERENCE_INITIAL,
  ASK_PREFERENCE_REGULAR,
  START_INITIAL,
  START_REGULAR,
  PLAY_INITIAL,
  PLAY_REGULAR,
  TEMP_SUCCESS_INITIAL,
  TEMP_SUCCESS_REGULAR,
  DEATH_INITIAL,
  DEATH_REGULAR
};

static entity Steve = {
  .row = 50,
  .col = 40,
  .image = steve
};

static entity Boulder = {
  .row = 100,
  .col = 200,
  .image = boulder
};

static entity Mountain = {
  .row = 100,
  .col = 30,
  .image = mountain
};

int deathsINT = 0;
int floatOffset;
int stepsINT;
char stepsSTR[25];
int preference;

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //

  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state

  enum gba_state state = ASK_PREFERENCE_INITIAL;

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    waitForVBlank();

    switch (state) {
      case ASK_PREFERENCE_INITIAL:
        deathsINT = 0;
        Steve.row = 50;
        Steve.col = 40;
        Boulder.col = 200;
        Boulder.row = 100;
        state = ASK_PREFERENCE_INITIAL;
        stepsINT = 0;

        fillScreenDMA(BLACK);
        drawCenteredString(10, 0, WIDTH, 10, "What's your preference?", WHITE);
        drawCenteredString(30, 0, WIDTH, 10, "Press UP if you'd like Ocean Theme.", WHITE);
        drawCenteredString(50, 0, WIDTH, 10, "Press DOWN if you'd like Mountain Theme.", WHITE);
        drawImageDMA(70, (WIDTH - COWBOY_WIDTH) / 2, COWBOY_WIDTH, COWBOY_HEIGHT, cowboy);

        state = ASK_PREFERENCE_REGULAR;
        break;


      case ASK_PREFERENCE_REGULAR:
        if (KEY_JUST_PRESSED(BUTTON_UP, currentButtons, previousButtons)) {
          preference = 0; // ocean theme
          state = START_INITIAL;
        } else if (KEY_JUST_PRESSED(BUTTON_DOWN, currentButtons, previousButtons)) {
          preference = 1; // mountain theme
          state = START_INITIAL;
        }
        break;

      case START_INITIAL:
        fillScreenDMA(BLACK);
        drawImageDMA(40, 60, SISYPHUS_WIDTH, SISYPHUS_HEIGHT, sisyphus);
        drawString(135, 60, "Press Enter to Start", WHITE);

        state = START_REGULAR;
        break;
        
      case START_REGULAR:
        
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          state = PLAY_INITIAL;
        } else if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = ASK_PREFERENCE_INITIAL;
        }

        // Manipulate floatOffset to make the rows go up and down within a range of 10
        static int direction = 1; // 1 for down, -1 for up
        floatOffset += direction;

        if (floatOffset > 10) {
          floatOffset = 10;
          direction = -1;
        } else if (floatOffset < 0) {
          floatOffset = 0;
          direction = 1;
        }

        // Fill the old sprite area with black
        drawRectDMA(20 + floatOffset - direction, 10, BOULDER_WIDTH, BOULDER_HEIGHT, BLACK);
        drawRectDMA(20 + floatOffset - direction, 230, BOULDER_WIDTH, BOULDER_HEIGHT, BLACK);


        // Draw the new image with updated position
        drawImageDMA(20 + floatOffset, 10, BOULDER_WIDTH, BOULDER_HEIGHT, boulder);
        drawImageDMA(20 + floatOffset, 230, BOULDER_WIDTH, BOULDER_HEIGHT, boulder);


        break;
        
      case PLAY_INITIAL:
        fillScreenDMA(preference == 0 ? BLUE : BROWN);
        drawRectDMA(0, 0, WIDTH, 20, GREY);
        drawImageDMA(Steve.row, Steve.col, STEVE_HEIGHT, STEVE_WIDTH, steve); 
        drawImageDMA(Boulder.row, Boulder.col, BOULDER_HEIGHT, BOULDER_WIDTH, boulder);
        drawRectDMA(100, 30, 25, 25, preference == 0 ? LIGHT_BLUE : LIGHT_BROWN);
        
        
        state = PLAY_REGULAR;
        break;
        
      case PLAY_REGULAR:
        drawRectDMA(100, 30, 25, 25, preference == 0 ? LIGHT_BLUE : LIGHT_BROWN);
        moveEntity(&Steve, currentButtons, preference == 0 ? BLUE : BROWN, &stepsINT);

        drawRectDMA(10, WIDTH / 2, WIDTH / 2, 10, GREY);
        snprintf(stepsSTR, sizeof(stepsSTR), "%d", stepsINT / 20);
        drawCenteredString(10, WIDTH / 2, WIDTH / 2, 10, stepsSTR, WHITE);

        if (detectCollision(&Steve, &Boulder)) {
          // if (KEY_DOWN(BUTTON_UP, currentButtons) && Boulder.row > 20) {
          //   Boulder.row--;
          // } else if (KEY_DOWN(BUTTON_DOWN, currentButtons) && Boulder.row + 10 < HEIGHT) {
          //   Boulder.row++;
          // } else if (KEY_DOWN(BUTTON_LEFT, currentButtons) && Boulder.col < 0) {
          //   Boulder.col--;
          // } else if (KEY_DOWN(BUTTON_RIGHT, currentButtons) && Boulder.col + 10 < WIDTH) {
          //   Boulder.col++;
          // }
            moveEntity(&Boulder, currentButtons, preference == 0 ? BLUE : BROWN, NULL);
        }

        drawImageDMA(Boulder.row, Boulder.col, 10, 10, boulder);

        if (Steve.row < 20) {
          state = DEATH_INITIAL;
        } else if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons))  {
          state = ASK_PREFERENCE_INITIAL;
        } else if (isFullyContained(&Mountain, &Boulder)) {
          state = TEMP_SUCCESS_INITIAL;
        }

        break;

      case TEMP_SUCCESS_INITIAL:
        Steve.row = 50;
        Steve.col = 40;
        Boulder.row = 100;
        Boulder.col = 200;

        drawImageDMA(0, 0, FALLOUT_WIDTH, FALLOUT_HEIGHT, fallout);
        drawCenteredString(0, 0, WIDTH, 20, "You must do this forever. Have fun!", WHITE);

        state = TEMP_SUCCESS_REGULAR;

        break;
      
      case TEMP_SUCCESS_REGULAR:
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = ASK_PREFERENCE_INITIAL;
        }

        break;
      case DEATH_INITIAL:
        Steve.row = 50;
        Steve.col = 40;
        Boulder.col = 200;
        Boulder.row = 100;
      
        deathsINT++;
        drawImageDMA(0, 0, YOUDIED_WIDTH, YOUDIED_HEIGHT - 40, youDied);
        drawRectDMA(120, 0, WIDTH, 40, BLACK);
        drawCenteredString(20, 0, WIDTH, 10, "Death is not an escape.", WHITE);
        drawCenteredString(40, 0, WIDTH, 10, "You must continue your punishment.", WHITE);
        drawCenteredString(120, 0, WIDTH, 10, "Press delete to start again.", WHITE);
        
        char deathSTR[16]; // Increased size to safely hold the formatted string
        snprintf(deathSTR, sizeof(deathSTR), "Deaths = %d", deathsINT);

        drawCenteredString(140, 0, WIDTH, 10, deathSTR, WHITE);
        state = DEATH_REGULAR;
        break;

      case DEATH_REGULAR:
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          // resetting position
          state = START_INITIAL;
        }
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}