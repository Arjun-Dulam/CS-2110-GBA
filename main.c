#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
#include "movementMethods.h"

#include "images/sisyphus.h"
#include "images/steve.h"
#include "images/boulder.h"
#include "images/youDied.h"


/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

// command to process image: nin10kit --mode=3 --resize=240x160 sisyphus sisyphus.png 

/* TODO: */
// Add any additional states you need for your app. You are not required to use
// these specific provided states.
enum gba_state {
  START_INITIAL,
  START_REGULAR,
  PLAY_INITIAL,
  PLAY_REGULAR,
  TEMP_SUCCESS,
  DEATH_INITIAL,
  DEATH_REGULAR
};

static entity Steve = {
  .row = 50,
  .col = 40,
  .image = steve
};

static entity Boulder = {
  .row = 100,
  .col = 200,
  .image = boulder
};

int deathsINT = 0;


int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //

  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state

  enum gba_state state = START_INITIAL;

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons
    

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    waitForVBlank();

    switch (state) {
      case START_INITIAL:
        fillScreenDMA(BLACK);
        drawImageDMA(40, 60, SISYPHUS_WIDTH, SISYPHUS_HEIGHT, sisyphus);

        state = START_REGULAR;
        break;
        
      case START_REGULAR:
        drawString(135 , 60, "Press Enter to Start", WHITE);
        
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          state = PLAY_INITIAL;
        }
        
        break;
        
      case PLAY_INITIAL:
        fillScreenDMA(BROWN);
        drawRectDMA(0, 0, WIDTH, 20, GREY);
        drawImageDMA(Steve.row, Steve.col, STEVE_HEIGHT, STEVE_WIDTH, steve); 
        drawImageDMA(Boulder.row, Boulder.col, BOULDER_HEIGHT, BOULDER_WIDTH, boulder);
        drawRectDMA(100, 30, 25, 25, LIGHT_BROWN);
        
        
        state = PLAY_REGULAR;
        break;
        
      case PLAY_REGULAR:
        moveEntity(&Steve, currentButtons, BROWN);

        if (Steve.row < 20) {
          state = DEATH_INITIAL;
        } else if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons))  {
          state = START_INITIAL;
        }

        break;

      case TEMP_SUCCESS:

        // state = ?
        break;
      case DEATH_INITIAL:
        deathsINT++;
        drawImageDMA(0, 0, YOUDIED_WIDTH, YOUDIED_HEIGHT - 40, youDied);
        drawRectDMA(120, 0, WIDTH, 40, BLACK);
        drawCenteredString(20, 0, WIDTH, 10, "Death is not an escape.", WHITE);
        drawCenteredString(40, 0, WIDTH, 10, "You must continue your punishment.", WHITE);
        drawCenteredString(120, 0, WIDTH, 10, "Press delete to start again.", WHITE);
        
        char deathSTR[16]; // Increased size to safely hold the formatted string
        snprintf(deathSTR, sizeof(deathSTR), "Deaths = %d", deathsINT);

        drawCenteredString(140, 0, WIDTH, 10, deathSTR, WHITE);
        state = DEATH_REGULAR;
        break;

      case DEATH_REGULAR:
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          // resetting position

          Steve.row = 50;
          Steve.col = 40;
          Boulder.row = 100;
          Boulder.col = 200;
          state = START_INITIAL;
        }

        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}